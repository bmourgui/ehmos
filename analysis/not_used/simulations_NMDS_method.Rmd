---
title: "Simulations to compare shift detection methods"
author: "Mourguiart, Bastien"
date: "14/11/2019"
output:
  pdf_document: default
  html_document:
    df_print: paged
---
```{r echo=FALSE}
library(vegan)
library(mgcv)
library(dplyr)
library(tidyr)
library(ggplot2)

```

Aim of the simulations is to see if the _nMDS method_ (1) is adapted to detect altitudinal shifts between two periods (2) to test if this method is better than a _t-test_ regarding the statistical power and the quality of the estimation. 

# Data description
Typically two contingency tables (in presence/absence), one for each sampling periods, with S rows corresponding to the S sites sampled in each period and N columns corresponding to the N species encountered at least one time in the both periods. One vector ($\mathbf{Alt}^{Site}=(Alt^{Site}_{1},  Alt^{Site}_{2},  ...  ,  Alt^{Site}_{j},  ...  ,  Alt^{Site}_{S})$) for the altitudes of the S sites. 




# Methods
## t-test
For each species i, we apply a t-test between the altitudes of the sites which are occupied in the period t2 and the altitudes of the sites which are occupied in the period t1 by species i. This give us an estimation of the altitudinal shift of each species: $\hat{\Delta}_{Ttest_{i}}$

## nMDS methods
### Two separated datas
First, dissimilarity matrices, representing the differences in species composition between each pair of sites, are calculated for the two periods using the Jaccard dissimilarity.  

We then perform two nMDS (non-metric MultiDimensional Scaling), one for each dissimilarity matrix, in order to visualize the pairwise dissimilarites among the S sites in a reduced number of dimensions. nMDS, by an iterative process, minimizes the stress:

$$
\begin{equation}
\tag{stress}
Stress=\frac{\sum_{i<j}[{\hat{\delta}_{ij}-f(\delta_{ij})}]^2}{\sum_{i<j}{\delta_{ij}^2}}
\end{equation}
$$

with $\hat{\delta}_{ij}$ the graphical distance between sites i and j, $\delta_{ij}$ the true dissimilarity and $f()$ a monotonic function.  
The species are projected in the new 'space' as centroids of the sites which they occupy. 

Once the site coordinates in the reduced 2D- or 3D-dimensions are obtained, a GAM (or lm) explaining site altitudes is fitted with the nMDS coordinates for each period: 

$$
\begin{equation}
\tag{GAM t1}
Alt^{Site}_{j}=f_{t1}(C1_{j_{t1}}) + g_{t1}(C2_{j_{t1}}) + \epsilon_{j_{t1}}  \quad where \quad \epsilon_{j_{t1}} \sim N(0,\sigma^2_{t1})
\end{equation}
$$

$$
\begin{equation}
\tag{GAM t2}
Alt^{Site}_{j}=f_{t2}(C1_{j_{t2}}) + g_{t2}(C2_{j_{t2}}) + \epsilon_{j_{t2}}  \quad where \quad \epsilon_{j_{t2}} \sim N(0,\sigma^2_{t2})
\end{equation}
$$

When the parameters associated to the functions involved in the GAMs ($f_{t2},g_{t2},f_{t1},g_{t1}$) are estimated, we predict the _optimal_ altitude of species i in each period using its graphical coordinates:
$$
\begin{equation}
\tag{predict t1}
\hat{Alt}^{species}_{i_{t1}}=\hat{f}_{t1}(C1_{i_{t1}}) + \hat{g}_{t1}(C2_{i_{t1}})
\end{equation}
$$
$$
\begin{equation}
\tag{predict t2}
\hat{Alt}^{species}_{i_{t2}}=\hat{f}_{t2}(C1_{i_{t2}}) + \hat{g}_{t2}(C2_{i_{t2}})
\end{equation}
$$

Finally, we estimate the altitudinal shift between the two periods: 
$$\hat{\Delta}_{2mds_{i}}=\hat{Alt}^{species}_{i_{t2}}-\hat{Alt}^{species}_{i_{t1}}$$

### One data
The two contingency tables are merged in one which has S rows (number of sites) and 2N columns (the double of species number). The first N columns correspond to the presence/absence of the N species at period t1 and the remaining N columns correspond to the presence/absence of the species at period t2.  

Then, a nMDS is performed on the dissimilarity matrix associated. Sites are projected in the graphical space and the position of the species is deduced for the two periods simultaneously. A GAM is fitted to the graphical coordinates of the S sites in order to explain their altitudes: 
$$
\begin{equation}
\tag{GAM unique}
Alt^{Site}_{s}=f(C1_{s}) + g(C2_{s}) + \epsilon_{s}
\end{equation}
$$

The _optimal_ altitude of each species at the two periods are predicted using the function parameters estimated with the GAM:
$$
\begin{equation}
\tag{predict t1}
\hat{Alt}^{species}_{i_{t1}}=\hat{f}(C1_{i}) + \hat{g}(C2_{i}) \quad with \quad i \quad in \quad [{1;N}]
\end{equation}
$$
$$
\begin{equation}
\tag{predict t2}
\hat{Alt}^{species}_{i_{t2}}=\hat{f}(C1_{i'}) + \hat{g}(C2_{i'}) \quad with \quad i'=i+N
\end{equation}
$$

Finally, we estimate the altitudinal shift:

$$\hat{\Delta}_{mds_{i}}=\hat{Alt}^{species}_{i_{t2}}-\hat{Alt}^{species}_{i_{t1}}$$

# Test under 'perfect' conditions
By perfect conditions, I mean that a species can not be missed if present at a site and a species with a definite range occupies all sites sampled in this range. 

For each species i, with i in {1,2,...,N=20}, true altitudinal mean at period t1 ($Alt^{species}_{i_{t1}}$) is randomly sampled between 400 and 1400m. And the true altitudinal shift between period t2 and period t1 ($\delta_{i}=Alt^{species}_{i_{t2}}-Alt^{species}_{i_{t1}}$) is fixed at 0 for 5 species and sample in $I=[-200 ; -75] \cup [75 ; 200]$ for the remaining 15 species. Then true altitudinal mean at period t2 ($Alt^{species}_{i_{t2}}$) is deduced.  
\smallbreak

```{r echo=TRUE, , echo=TRUE}
N <- 20
set.seed(20)
true.meanT1 <- sample(400:1400, N)
true.dif <- c(sample(c(-200:-75,75:200), N-5),rep(0,5))
true.meanT2 <- true.meanT1+true.dif


S <- 150

comm1 <- data.frame("spA"=rep(0,S), "spB"=0, "spC"=0, "spD"=0, "spE"=0, "spF"=0, "spG"=0, "spH"=0, "spI"=0, "spJ"=0, "spK"=0,"spL"=0, "spM"=0, "spN"=0, "spP"=0, "spQ"=0, "spR"=0,"spS"=0, "spT"=0, "spU"=0)
comm2 <- data.frame("spA"=rep(0,S), "spB"=0, "spC"=0, "spD"=0, "spE"=0, "spF"=0, "spG"=0, "spH"=0, "spI"=0, "spJ"=0, "spK"=0,"spL"=0, "spM"=0, "spN"=0, "spP"=0, "spQ"=0, "spR"=0,"spS"=0, "spT"=0, "spU"=0)

R <- 10 #replicate number
for (r in 1:R){
  
  alti.site <- sample(200:1600,S)
  for (i in 1:ncol(comm1)){
    
    z <- abs(alti.site - true.meanT1[i])
    comm1[,i] <- as.numeric(z <= 200)
    
    z2 <- abs(alti.site - true.meanT2[i])
    comm2[,i] <- as.numeric(z2 <= 200)
    
  }
}  
```

```{r eval=FALSE, include=FALSE}
S <- 150

comm1 <- data.frame("spA"=rep(0,S), "spB"=0, "spC"=0, "spD"=0, "spE"=0, "spF"=0, "spG"=0, "spH"=0, "spI"=0, "spJ"=0, "spK"=0,"spL"=0, "spM"=0, "spN"=0, "spP"=0, "spQ"=0, "spR"=0,"spS"=0, "spT"=0, "spU"=0)
comm2 <- data.frame("spA"=rep(0,S), "spB"=0, "spC"=0, "spD"=0, "spE"=0, "spF"=0, "spG"=0, "spH"=0, "spI"=0, "spJ"=0, "spK"=0,"spL"=0, "spM"=0, "spN"=0, "spP"=0, "spQ"=0, "spR"=0,"spS"=0, "spT"=0, "spU"=0)

R <- 10 #replicate number
for (r in 1:R){
  
  alti.site <- sample(200:1600,S)
  for (i in 1:ncol(comm1)){
    
    z <- abs(alti.site - true.meanT1[i])
    comm1[,i] <- as.numeric(z <= 200)
    
    z2 <- abs(alti.site - true.meanT2[i])
    comm2[,i] <- as.numeric(z2 <= 200)
    
  }
  
  ##### mean comparison #####
  X.t1b <- comm1*alti.site
  X.t2b <- comm2*alti.site
  
  X.t1b[X.t1b==0] <- NA
  X.t2b[X.t2b==0] <- NA
  
  confint.mean.t1<- data.frame("taxon"=colnames(comm1), 
                              "fit"=0,
                              "lwr"=0,
                              "upr"=0)
  for (j in 1:ncol(comm1)){
    testmean <- t.test(X.t1b[,j])
    confint.mean.t1[j,2] <- testmean$estimate[1]
    confint.mean.t1[j,3:4] <- testmean$conf.int
  }
  
  confint.mean.t2<- data.frame("taxon"=colnames(comm1), 
                              "fit"=0,
                              "lwr"=0,
                              "upr"=0)
  for (j in 1:ncol(comm1)){
    testmean <- t.test(X.t2b[,j])
    confint.mean.t2[j,2] <- testmean$estimate[1]
    confint.mean.t2[j,3:4] <- testmean$conf.int
  }
  
  estim.dif.mean <- data.frame("taxon"=colnames(comm1), 
                              "fit"=0,
                              "lwr"=0,
                              "upr"=0)
  
  for (j in 1:ncol(comm1)){
    testmean <- t.test(X.t2b[,j], X.t1b[,j])
    estim.dif.mean[j,2] <- testmean$estimate[1]-testmean$estimate[2]
    estim.dif.mean[j,3:4] <- testmean$conf.int
  }
  
  ##### Two MDS 2D #######
  X.t1MDS <- comm1[rowSums(comm1)>0,]
  X.t2MDS <- comm2[rowSums(comm2)>0,]
  
  mds.t1 <- metaMDS(X.t1MDS, k=2, trymax=250, dist = "jaccard", trace=0, expand=FALSE)
  mds.t2 <- metaMDS(X.t2MDS, k=2, trymax=250, dist = "jaccard", trace=0, expand=FALSE) 
  
  NMDS.datat1 <- as.data.frame(mds.t1$species) 
  NMDS.datat2 <- as.data.frame(mds.t2$species)
    
    
    #GAM: graph coordinates ~ sites' altitude
  points.mdst1 <- data.frame("altitude"=alti.site[rowSums(comm1)>0] , #si on a enleve des lignes n ayant que de 0 pour les esp, penser a enelver les stations ici
                             "MDS1"=mds.t1$points[,1], "MDS2"=mds.t1$points[,2])
  points.mdst2 <- data.frame("altitude"=alti.site[rowSums(comm2)>0] , #si on a enleve des lignes n ayant que de 0 pour les esp, penser a enelver les stations ici
                             "MDS1"=mds.t2$points[,1], "MDS2"=mds.t2$points[,2])
  lmt1 <- gam(altitude ~ s(MDS1) + s(MDS2), data=points.mdst1)
  lmt2 <- gam(altitude ~ s(MDS1) + s(MDS2), data=points.mdst2)
    
    #Prediction of species altitudinal position
  confint.2MDS.t1 <- predict.gam(lmt1, newdata = NMDS.datat1, interval = "confidence")
  confint.2MDS.t2 <- predict.gam(lmt2, newdata = NMDS.datat2, interval = "confidence")
    
  
  ##### Two MDS 3D #######
  
  mds3d.t1 <- metaMDS(X.t1MDS, k=3, trymax=250, dist = "jaccard", trace=0, expand=FALSE)
  mds3d.t2 <- metaMDS(X.t2MDS, k=3, trymax=250, dist = "jaccard", trace=0, expand=FALSE) 
  
  NMDS3d.datat1 <- as.data.frame(mds3d.t1$species) 
  NMDS3d.datat2 <- as.data.frame(mds3d.t2$species)
    
    
    #GAM: graph coordinates ~ sites' altitude
  points.mds3dt1 <- data.frame("altitude"=alti.site[rowSums(comm1)>0] , #si on a enleve des lignes n ayant que de 0 pour les esp, penser a enelver les stations ici
                             "MDS1"=mds3d.t1$points[,1], "MDS2"=mds3d.t1$points[,2], "MDS3"=mds3d.t1$points[,3])
  points.mds3dt2 <- data.frame("altitude"=alti.site[rowSums(comm2)>0] , #si on a enleve des lignes n ayant que de 0 pour les esp, penser a enelver les stations ici
                             "MDS1"=mds3d.t2$points[,1], "MDS2"=mds3d.t2$points[,2], "MDS3"=mds3d.t2$points[,3])
  lm3dt1 <- gam(altitude ~ s(MDS1) + s(MDS2) + s(MDS3), data=points.mds3dt1)
  lm3dt2 <- gam(altitude ~ s(MDS1) + s(MDS2) + s(MDS3), data=points.mds3dt2)
    
    #Prediction of species altitudinal position
  confint.2MDS3d.t1 <- predict.gam(lm3dt1, newdata = NMDS3d.datat1, interval = "confidence")
  confint.2MDS3d.t2 <- predict.gam(lm3dt2, newdata = NMDS3d.datat2, interval = "confidence")
    
  
  
  ###### One MDS 2D #######
  comm3 <- cbind(comm1, comm2)
  colnames(comm3) <- c(paste(colnames(comm1), "T1", sep="_"),paste(colnames(comm1), "T2", sep="_"))
    
  X.t3MDS <- comm3[rowSums(comm3)>0,]
    
  mds.unique <- metaMDS(X.t3MDS, k=2, trymax=250, dist = "jaccard", trace=0, shrinkage=T)
    
  NMDS.datat3 <- as.data.frame(mds.unique$species)
    
  #Relation (lineaire) positionnement graphique et altitude
  points.mds.unique <- data.frame("altitude"=alti.site[rowSums(comm3)>0] , #si on a enleve des lignes n ayant que de 0 pour les esp, penser a enelver les stations ici
                                  "MDS1"=mds.unique$points[,1], "MDS2"=mds.unique$points[,2])
    
  lm.unique <- gam(altitude ~ s(MDS1) + s(MDS2), data=points.mds.unique)
  #Prediction position altitudinale des especes
  confint.MDS.t1 <- predict.gam(lm.unique, newdata = NMDS.datat3[1:N,], interval = "confidence")
  confint.MDS.t2 <- predict.gam(lm.unique, newdata = NMDS.datat3[(N+1):(2*N),], interval = "confidence")
  
  
  
  ###### One MDS 3D #######
  
  mds3d.unique <- metaMDS(X.t3MDS, k=3, trymax=250, dist = "jaccard", trace=0, shrinkage=T)
  NMDS3d.datat3 <- as.data.frame(mds3d.unique$species)
    
  #Relation (lineaire) positionnement graphique et altitude
  points.mds3d.unique <- data.frame("altitude"=alti.site[rowSums(comm3)>0] , #si on a enleve des lignes n ayant que de 0 pour les esp, penser a enelver les stations ici
                                  "MDS1"=mds3d.unique$points[,1], "MDS2"=mds3d.unique$points[,2], "MDS3"=mds3d.unique$points[,3])
    
  lm.unique3d <- gam(altitude ~ s(MDS1) + s(MDS2) + s(MDS3), data=points.mds3d.unique)
  #Prediction position altitudinale des especes
  confint.MDS3d.t1 <- predict.gam(lm.unique3d, newdata = NMDS3d.datat3[1:N,], interval = "confidence")
  confint.MDS3d.t2 <- predict.gam(lm.unique3d, newdata = NMDS3d.datat3[(N+1):(2*N),], interval = "confidence")

  if(r==1){
    result <- array(c(confint.mean.t1$fit, confint.2MDS.t1, confint.2MDS3d.t1, confint.MDS.t1, confint.MDS3d.t1,
                      confint.mean.t2$fit, confint.2MDS.t2, confint.2MDS3d.t2, confint.MDS.t2, confint.MDS3d.t2), 
                      dim=c(N,5,2,R))
    
    gams.2MDS.t1 <- list(lmt1)
    gams.2MDS3d.t1 <- list(lm3dt1)
    gams.2MDS.t2 <- list(lmt2)
    gams.2MDS3d.t2 <- list(lm3dt2)
    gams.MDS <- list(lm.unique)
    gams.MDS3d <- list(lm.unique3d)
    
    MDS2.t1 <- list(mds.t1)
    MDS2.t2 <- list(mds.t2)
    MDS2.3d.t1 <- list(mds3d.t1)
    MDS3.3d.t2 <- list(mds3d.t1)
    MDS.unique <- list(mds.unique)
    MDS.3dunique <- list(mds3d.unique)

  }else{
    result[,,,r] <- c(confint.mean.t1$fit, confint.2MDS.t1, confint.2MDS3d.t1, confint.MDS.t1, confint.MDS3d.t1,
                    confint.mean.t2$fit, confint.2MDS.t2, confint.2MDS3d.t2, confint.MDS.t2, confint.MDS3d.t2)
    gams.2MDS.t1[[r]] <- lmt1
    gams.2MDS3d.t1[[r]] <- lm3dt1
    gams.2MDS.t2[[r]] <- lmt2
    gams.2MDS3d.t2[[r]] <- lm3dt2
    gams.MDS[[r]] <- lm.unique
    gams.MDS3d[[r]] <- lm.unique3d
    
    MDS2.t1[[r]] <- mds.t1
    MDS2.t2[[r]] <- mds.t2
    MDS2.3d.t1[[r]] <- mds3d.t1
    MDS3.3d.t2[[r]] <- mds3d.t1
    MDS.unique[[r]] <- mds.unique
    MDS.3dunique[[r]] <- mds3d.unique
  }


}

erreur.T1 <- apply((result[,,1,]-true.meanT1)^2,2,mean)
var.erreur.T1 <- apply((result[,,1,]-true.meanT1)^2,2,sd)/R
erreur.T2 <- apply((result[,,2,]-true.meanT2)^2,2,mean)
var.erreur.T2 <- apply((result[,,2,]-true.meanT2)^2,2,sd)/R

as.data.frame(apply(result[,,2,]-result[,,1,], c(1,2), mean)) %>%
  gather(key = "method", value = "Alt", 1:5) %>%
  mutate("method"=as.factor(method)) %>%
  mutate("species"=rep(colnames(comm1),5)) -> mean.estim.T1
levels(mean.estim.T1$method) <- c("mean","TwoMDS","TwoMDS3d","OneMDS","OneMDS3d")

as.data.frame(apply(result[,,2,]-result[,,1,], c(1,2), sd)) %>%
  gather(key = "method", value = "Alt", 1:5) %>%
  mutate("method"=as.factor(method)) %>%
  mutate("species"=rep(colnames(comm1),5)) -> sd.estim.T1
levels(sd.estim.T1$method) <- c("mean","TwoMDS","TwoMDS3d","OneMDS","OneMDS3d")

mean.estim.T1$minAlt <- mean.estim.T1$Alt - sd.estim.T1$Alt
mean.estim.T1$maxAlt <- mean.estim.T1$Alt + sd.estim.T1$Alt

ggplot(data=mean.estim.T1, aes(x=species, y=Alt)) +
  geom_point() +
  geom_errorbar(aes(ymin=minAlt, ymax=maxAlt)) +
  facet_wrap(~method) +
  theme_classic() +
  geom_point(data=data.frame("species"=rep(colnames(comm1),5), "method"=mean.estim.T1$method, "Alt"=rep(true.dif, 5)), aes(x=species, y=Alt), color="red", shape=3)

```


# Test in 'real' conditions
We used the sampling design of our study
```{r eval=FALSE, include=FALSE}
library(readxl)
gueguen1980 <- read_excel("data_PNM_gueguen.xlsx", sheet="gueguen1980")
alti.site <- gueguen1980$altitude
```

I defined detection/non-detection data, $X_{i,j}$, of species $i$ at site $j$ as:
$$X_{i,j} \sim Bernoulli(Z_{i,j} \times p_i)$$

where $p_i$ is the detection probability of species $i$ which can be less than 1, and $Z_{i,j}$ is a binary variable representing the true occupancy state of site $j$ by species $i$. In this manner, a species could be present at a site ($Z_{i,j}=1$) and not detected ($X_{i,j}=0$), and if a species is trully absent then it could not be detected. The true occupancy state was modelled as an outcome of a Bernoulli variable depending on the occupancy probability ($\psi_{i,j} $) of species $i$ at site $j$: 

$$Z_{i,j} \sim Bernoulli(\psi_{i,j})$$

The occupancy probability of a species is assumed to vary with the altitude according to a unimodal relationship. So, I modelled the occupancy probability on the logit scale with a regression involving both linear and quadratic effects of the altitude that vary among species. At period t1, the occupancy probability on the logit scale is defined as: 

$$logit(\psi_{i,j}) = a_i + b_i \times {AltiS_{j}}^{site} + c_i \times {{AltiS_{j}}^{site}}^2$$
where ${AltiS_{j}}^{site}$ is the standardized (centered and scaled) altitude of site $j$. This gives us the true altitudinal optimum of species $i$ at period $t1$ by: ${Alti_{i_{t1}}}^{species}=\frac{-b_i \times \sigma_{alti}}{2c_i}+\mu_{alti}$, with $\sigma_{alti}$ is the standard deviation of the altitudes of the sampling sites and $\mu_{alti}$ the mean.  

For the period t2, I calculated the occupancy probability as:

$$logit(\psi_{i,j}) = a_i + b_i \times (AltiS_{j} - \frac{\Delta_{i}}{\sigma_{alti}}) + c_i \times  (AltiS_{j} - \frac{\Delta_{i}}{\sigma_{alti}})^2$$
where $\Delta_i$ is the true altitudinal shift of species $i$ that gives us the true altitudinal optimum at period $t2$: ${Alti_{i_{t2}}}^{species}={Alti_{i_{t1}}}^{species}+\Delta_i$.
  
I used estimates of $a_i$, $b_i$, $c_i$ and $p_i$ from the other part of my internship to simulate once the true occupancy probabilities $\psi_{i,j}$ and the true occupancy states $Z_{i,j}$, and to simulate multiple times the observation process $X_{i,j}$ for each period. Then I used the datasets created to test the methods. 

```{r echo=TRUE}
library(readxl)
library(parallel)
library(ggpubr)
library(vegan)
library(mgcv)
gueguen1980 <- read_excel("data_PNM_gueguen.xlsx", sheet="gueguen1980")
load("results_modelFinalN2.RData")
load("modelFinal.RData")
out <- out.modelFinalN2

  x <- gueguen1980$altitude
  alti.site <- x
  
  S <- length(x)
  N <- 20
  
  true.mean1 <- sample(900:2300, N)
  true.diff <- c(rep(0,3), sample(30:200, (N-3)))
  true.mean2 <- true.mean1 + true.diff
  
  a0 <- 1
  r <- 800
  alp <- 6
  gma <- 6
  b <- alp / (alp+gma)
  d <- (b^alp) * ((1-b)^gma)
  
  psi.t1 <- matrix(0, ncol=N, nrow=S)
  psi.t2 <- matrix(0, ncol=N, nrow=S)
  Z1 <- matrix(0, ncol=N, nrow=S)
  Z2 <- matrix(0, ncol=N, nrow=S)
  
  for (i in 1:N){
    A1 <- (a0/d) * ((x - true.mean1[i])/r + b)^alp * (1 - ((x - true.mean1[i])/r + b))^gma
    psi.t1[,i] <- A1
    psi.t1[x < (true.mean1[i]-r*b) | x > (true.mean1[i]+r*b),i] <- 0
    
    A2 <- (a0/d) * ((x - true.mean2[i])/r + b)^alp * (1 - ((x - true.mean2[i])/r + b))^gma
    psi.t2[,i] <- A2
    psi.t2[x < (true.mean2[i]-r*b) | x > (true.mean2[i]+r*b),i] <- 0
    
    Z1[,i] <- rbinom(n=S, size=1, prob=psi.t1[,i])
    Z2[,i] <- rbinom(n=S, size=1, prob=psi.t2[,i])
  }
  
  
  X1 <- matrix(nrow=S, ncol = N)
  X2 <- matrix(nrow=S, ncol = N)
  
  R <- 50 #replicate number
  Xl1 <- list()
  Xl2 <- list()
  Xl3 <- list()
  p <- runif(N, min=0.8, max=1)
  
  
          for (r in 1:R){
            for (i in 1:N){
              X1[,i] <- rbinom(n=S, size=1, prob=p[i]*Z1[,i])
              X2[,i] <- rbinom(n=S, size=1, prob=p[i]*Z2[,i])
            }
            Xl1[[r]] <- X1
            Xl2[[r]] <- X2
            Xl3[[r]] <- cbind(X1, X2)
          }
          
          
          X1b <- mclapply(Xl1, function(x)(x*alti.site))
          X2b <- mclapply(Xl2, function(x)(x*alti.site))
          
          X1b <- mclapply(X1b, function(x)(replace(x, x==0, NA)))
          X2b <- mclapply(X2b, function(x)(replace(x, x==0, NA)))
          
          estim.mean1 <- mclapply(X1b, function(x)colMeans(x, na.rm=TRUE))
          estim.mean2 <- mclapply(X2b, function(x)colMeans(x, na.rm=TRUE))
          
          estim.mean.sup1 <- list()
          estim.mean.inf2 <- list()
          for (r in 1:R){
            if(sum(colSums(Xl1[[r]])<3) > 0){
              estim.mean.sup1[[r]] <- rep(NA, N)
            }else{
              estim.mean.sup1[[r]] <- apply(X1b[[r]], 2,function(y)t.test(y, na.rm=TRUE)$conf.int[2])
            }
            if(sum(colSums(Xl2[[r]])<3) > 0){
              estim.mean.inf2[[r]] <- rep(NA, N)
            }else{
              estim.mean.inf2[[r]] <- apply(X2b[[r]],2,function(y)t.test(y, na.rm=TRUE)$conf.int[1])
            }
          }
          
          
          ###### double MDS #####
          
          X1.mds <- mclapply(Xl1, function(x)(x[!apply(x == 0, 1, all),])) #remove empty rows
          X2.mds <- mclapply(Xl2, function(x)(x[!apply(x == 0, 1, all),])) #datas for the mds
          X3.mds <- mclapply(Xl3, function(x)(x[!apply(x == 0, 1, all),]))
          
          #run mds
          mds1.2D <-mclapply(X1.mds, function(x)(metaMDS(x, k=2, trymax=250, dist = "jaccard", trace=1, expand=F)))
          mds1.3D <-mclapply(X1.mds, function(x)(metaMDS(x, k=3, trymax=250, dist = "jaccard", trace=0, expand=F)))
          
          mds2.2D <-mclapply(X2.mds, function(x)(metaMDS(x, k=2, trymax=250, dist = "jaccard", trace=0, expand=F)))
          mds2.3D <-mclapply(X2.mds, function(x)(metaMDS(x, k=3, trymax=250, dist = "jaccard", trace=0, expand=F)))
          
          mdsU.2D <-mclapply(X3.mds, function(x)(metaMDS(x, k=2, trymax=250, dist = "jaccard", trace=0, expand=F)))
          mdsU.3D <-mclapply(X3.mds, function(x)(metaMDS(x, k=3, trymax=250, dist = "jaccard", trace=0, expand=F)))
  
  
  
  site.mds1.2D <- list()
  site.mds1.3D <- list()
  
  site.mds2.2D <- list()
  site.mds2.3D <- list()
  
  site.mdsU.2D <- list()
  site.mdsU.3D <- list()
  
  
  lm.mds1.2D <- list()
  lm.mds1.3D <- list()
  
  lm.mds2.2D <- list()
  lm.mds2.3D <- list()
  
  lm.mdsU.2D <- list()
  lm.mdsU.3D <- list()
  
  
  gam.mds1.2D <- list()
  gam.mds1.3D <- list()
  
  gam.mds2.2D <- list()
  gam.mds2.3D <- list()
  
  gam.mdsU.2D <- list()
  gam.mdsU.3D <- list()
  
  
  sp.mds1.2D <- list()
  sp.mds1.3D <- list()
  
  sp.mds2.2D <- list()
  sp.mds2.3D <- list()
  
  sp.mdsU.2D <- list()
  sp.mdsU.3D <- list()
  
  
  
  estim <- array(0, dim=c(N,9,R))
  estim1 <- array(0, dim=c(N,9,R))
  estim2 <- array(0, dim=c(N,9,R))
  estim.sup1 <- array(0, dim=c(N,9,R))
  estim.inf2 <- array(0, dim=c(N,9,R))
  
  for (r in 1:R){
    #Extract graphical coordinates of sites
    site.mds1.2D[[r]] <- data.frame("alti"=alti.site[rowSums(Xl1[[r]])>0], 
                            "MDS1"=mds1.2D[[r]]$points[,1], 
                            "MDS2"=mds1.2D[[r]]$points[,2])
    site.mds1.3D[[r]] <- data.frame("alti"=alti.site[rowSums(Xl1[[r]])>0], 
                            "MDS1"=mds1.3D[[r]]$points[,1], 
                            "MDS2"=mds1.3D[[r]]$points[,2],
                            "MDS3"=mds1.3D[[r]]$points[,3])
  
    site.mds2.2D[[r]] <- data.frame("alti"=alti.site[rowSums(Xl2[[r]])>0], 
                            "MDS1"=mds2.2D[[r]]$points[,1], 
                            "MDS2"=mds2.2D[[r]]$points[,2])
    site.mds2.3D[[r]] <- data.frame("alti"=alti.site[rowSums(Xl2[[r]])>0], 
                            "MDS1"=mds2.3D[[r]]$points[,1], 
                            "MDS2"=mds2.3D[[r]]$points[,2],
                            "MDS3"=mds2.3D[[r]]$points[,3])
  
    site.mdsU.2D[[r]] <- data.frame("alti"=alti.site[rowSums(Xl3[[r]])>0], 
                            "MDS1"=mdsU.2D[[r]]$points[,1], 
                            "MDS2"=mdsU.2D[[r]]$points[,2])
    site.mdsU.3D[[r]] <- data.frame("alti"=alti.site[rowSums(Xl3[[r]])>0], 
                            "MDS1"=mdsU.3D[[r]]$points[,1], 
                            "MDS2"=mdsU.3D[[r]]$points[,2],
                            "MDS3"=mdsU.3D[[r]]$points[,3])
    
    
    #fit models
    lm.mds1.2D[[r]] <- lm(alti ~ MDS1 + MDS2, data=site.mds1.2D[[r]])
    lm.mds1.3D[[r]] <- lm(alti ~ MDS1 + MDS2 + MDS3, data=site.mds1.3D[[r]])
  
    lm.mds2.2D[[r]] <- lm(alti ~ MDS1 + MDS2, data=site.mds2.2D[[r]])
    lm.mds2.3D[[r]] <- lm(alti ~ MDS1 + MDS2 + MDS3, data=site.mds2.3D[[r]])
  
    lm.mdsU.2D[[r]] <- lm(alti ~ MDS1 + MDS2, data=site.mdsU.2D[[r]])
    lm.mdsU.3D[[r]] <- lm(alti ~ MDS1 + MDS2 + MDS3, data=site.mdsU.3D[[r]])
  
  
    gam.mds1.2D[[r]] <- gam(alti ~ s(MDS1) + s(MDS2), data=site.mds1.2D[[r]])
    gam.mds1.3D[[r]] <- gam(alti ~ s(MDS1) + s(MDS2) + s(MDS3), data=site.mds1.3D[[r]])
  
    gam.mds2.2D[[r]] <- gam(alti ~ s(MDS1) + s(MDS2), data=site.mds2.2D[[r]])
    gam.mds2.3D[[r]] <- gam(alti ~ s(MDS1) + s(MDS2) + s(MDS3), data=site.mds2.3D[[r]])
  
    gam.mdsU.2D[[r]] <- gam(alti ~ s(MDS1) + s(MDS2), data=site.mdsU.2D[[r]])
    gam.mdsU.3D[[r]] <- gam(alti ~ s(MDS1) + s(MDS2) + s(MDS3), data=site.mdsU.3D[[r]])
    
    
    #species graphic coordinates
    sp.mds1.2D[[r]] <- as.data.frame(mds1.2D[[r]]$species)
    sp.mds1.3D[[r]] <- as.data.frame(mds1.3D[[r]]$species)
  
    sp.mds2.2D[[r]] <- as.data.frame(mds2.2D[[r]]$species)
    sp.mds2.3D[[r]] <- as.data.frame(mds2.3D[[r]]$species)
  
    sp.mdsU.2D[[r]] <- as.data.frame(mdsU.2D[[r]]$species)
    sp.mdsU.3D[[r]] <- as.data.frame(mdsU.3D[[r]]$species)
  
  
    #Predict species altitudes
    estim1[,2,r] <- predict.lm(lm.mds1.2D[[r]], sp.mds1.2D[[r]])
    estim1[,3,r] <- predict.lm(lm.mds1.3D[[r]], sp.mds1.3D[[r]])
    
    estim1[,4,r] <- predict.gam(gam.mds1.2D[[r]], sp.mds1.2D[[r]])
    estim1[,5,r] <- predict.gam(gam.mds1.3D[[r]], sp.mds1.3D[[r]])
  
    
    estim1[,6,r] <- predict.lm(lm.mdsU.2D[[r]], sp.mdsU.2D[[r]])[1:N]
    estim1[,7,r] <- predict.lm(lm.mdsU.3D[[r]], sp.mdsU.3D[[r]])[1:N]
    
    estim1[,8,r] <- predict.gam(gam.mdsU.2D[[r]], sp.mdsU.2D[[r]])[1:N]
    estim1[,9,r] <- predict.gam(gam.mdsU.3D[[r]], sp.mdsU.3D[[r]])[1:N]
    
    
    estim2[,2,r] <- predict.lm(lm.mds2.2D[[r]], sp.mds2.2D[[r]]) 
    estim2[,3,r] <- predict.lm(lm.mds2.3D[[r]], sp.mds2.3D[[r]]) 
    
    estim2[,4,r] <- predict.gam(gam.mds2.2D[[r]], sp.mds2.2D[[r]])
    estim2[,5,r] <- predict.gam(gam.mds2.3D[[r]], sp.mds2.3D[[r]]) 
  
    
    estim2[,6,r] <- (predict.lm(lm.mdsU.2D[[r]], sp.mdsU.2D[[r]])[(N+1):(2*N)]) 
    estim2[,7,r] <- (predict.lm(lm.mdsU.3D[[r]], sp.mdsU.3D[[r]])[(N+1):(2*N)]) 
    
    estim2[,8,r] <- (predict.gam(gam.mdsU.2D[[r]], sp.mdsU.2D[[r]])[(N+1):(2*N)]) 
    estim2[,9,r] <- (predict.gam(gam.mdsU.3D[[r]], sp.mdsU.3D[[r]])[(N+1):(2*N)]) 
    
    
    
  
    estim.sup1[,2,r] <- predict.lm(lm.mds1.2D[[r]], sp.mds1.2D[[r]], interval="confidence")[,3]
    estim.sup1[,3,r] <- predict.lm(lm.mds1.3D[[r]], sp.mds1.3D[[r]], interval="confidence")[,3]
    
  
    estim.sup1[,4,r] <- predict.gam(gam.mds1.2D[[r]], sp.mds1.2D[[r]]) + 1.96*predict.gam(gam.mds1.2D[[r]], sp.mds1.2D[[r]], se.fit = T)$se.fit
    estim.sup1[,5,r] <- predict.gam(gam.mds1.3D[[r]], sp.mds1.3D[[r]]) + 1.96*predict.gam(gam.mds1.3D[[r]], sp.mds1.3D[[r]], se.fit = T)$se.fit
  
    
    estim.sup1[,6,r] <- predict.lm(lm.mdsU.2D[[r]], sp.mdsU.2D[[r]][1:N,], interval="confidence")[,3]
    estim.sup1[,7,r] <- predict.lm(lm.mdsU.3D[[r]], sp.mdsU.3D[[r]][1:N,], interval="confidence")[,3]
    
    estim.sup1[,8,r] <- predict.gam(gam.mdsU.2D[[r]], sp.mdsU.2D[[r]])[1:N] + 1.96*predict.gam(gam.mdsU.2D[[r]], sp.mdsU.2D[[r]],se.fit=T)$se.fit[1:N]
    estim.sup1[,9,r] <- predict.gam(gam.mdsU.3D[[r]], sp.mdsU.3D[[r]])[1:N] + 1.96*predict.gam(gam.mdsU.3D[[r]], sp.mdsU.3D[[r]],se.fit=T)$se.fit[1:N]
    
    
    estim.inf2[,2,r] <- predict.lm(lm.mds2.2D[[r]], sp.mds2.2D[[r]], interval="confidence")[,2] 
    estim.inf2[,3,r] <- predict.lm(lm.mds2.3D[[r]], sp.mds2.3D[[r]], interval="confidence")[,2] 
    
    estim.inf2[,4,r] <- predict.gam(gam.mds2.2D[[r]], sp.mds2.2D[[r]]) - 1.96*predict.gam(gam.mds2.2D[[r]], sp.mds2.2D[[r]], se.fit = T)$se.fit
    estim.inf2[,5,r] <- predict.gam(gam.mds2.2D[[r]], sp.mds2.2D[[r]]) - 1.96*predict.gam(gam.mds2.2D[[r]], sp.mds2.2D[[r]], se.fit = T)$se.fit
  
    
    estim.inf2[,6,r] <- predict.lm(lm.mdsU.2D[[r]], sp.mdsU.2D[[r]][(N+1):(2*N),], interval="confidence")[,2] 
    estim.inf2[,7,r] <- predict.lm(lm.mdsU.3D[[r]], sp.mdsU.3D[[r]][(N+1):(2*N),], interval="confidence")[,2] 
    
    estim.inf2[,8,r] <- predict.gam(gam.mdsU.2D[[r]], sp.mdsU.2D[[r]])[(N+1):(2*N)] - 1.96*predict.gam(gam.mdsU.2D[[r]], sp.mdsU.2D[[r]],se.fit=T)$se.fit[(N+1):(2*N)]
    estim.inf2[,9,r] <- predict.gam(gam.mdsU.3D[[r]], sp.mdsU.3D[[r]])[(N+1):(2*N)] - 1.96*predict.gam(gam.mdsU.3D[[r]], sp.mdsU.3D[[r]],se.fit=T)$se.fit[(N+1):(2*N)]
  
  }
  
  estim1[,1,] <- as.numeric(unlist(estim.mean1))
  estim2[,1,] <- as.numeric(unlist(estim.mean2))
  estim.sup1[,1,] <- as.numeric(unlist(estim.mean.sup1))
  estim.inf2[,1,] <- as.numeric(unlist(estim.mean.inf2))
  
  estim <- estim2 - estim1
  
  shift.detect <- estim1[-c(1:3),,] < estim.inf2[-c(1:3),,] & estim2[-c(1:3),,] > estim.sup1[-c(1:3),,]
  no.shift.confirmed <- estim1[c(1:3),,] > estim.inf2[c(1:3),,] & estim2[c(1:3),,] < estim.sup1[c(1:3),,]
  
  shift.detect <- estim.inf2[-c(1:3),,]  > estim.sup1[-c(1:3),,]
  no.shift.confirmed <- estim.inf2[c(1:3),,]  < estim.sup1[c(1:3),,]
  
  results <- data.frame("species"=c(rep("mean",9), rep(paste("sp", 1:N, sep=""), 9)), "abs.diff"=NA, "error.mean"=NA,
                        "sd.error.mean"=NA, "power.diff"=NA, "power.no.diff"=NA, 
                        "method"=c(c("mean",
                                   "MDS_dble.2D.lm",
                                   "MDS_dble.3D.lm",
                                   "MDS_dble.2D.gam",
                                   "MDS_dble.3D.gam",
                                   "MDSU.2D.lm",
                                   "MDSU.3D.lm",
                                   "MDSU.2D.gam",
                                   "MDSU.3D.gam"),
                                   rep(c("mean",
                                   "MDS_dble.2D.lm",
                                   "MDS_dble.3D.lm",
                                   "MDS_dble.2D.gam",
                                   "MDS_dble.3D.gam",
                                   "MDSU.2D.lm",
                                   "MDSU.3D.lm",
                                   "MDSU.2D.gam",
                                   "MDSU.3D.gam"), each=N)))
  
  diff.abs <- abs(estim - array(true.diff, dim=c(N, 9, R)))
  error <- (estim - array(true.diff, dim=c(N, 9, R)))^2
  
  results[,2] <- c(apply(diff.abs, 2, function(x)mean(x,na.rm=T)), as.numeric(apply(diff.abs, c(1,2), function(x)mean(x,na.rm=T))))
  results[,3] <- c(apply(error, 2, function(x)mean(x,na.rm=T)), as.numeric(apply(error, c(1,2), function(x)mean(x,na.rm=T))))
  results[,4] <- c(apply(error, 2, function(x)(sd(x,na.rm=T)/N)), as.numeric(apply(error, c(1,2), function(x)(sd(x,na.rm=T)/R))))
  results[,5] <- apply(shift.detect, 2, function(x)mean(x, na.rm = T))
  results[,6] <- apply(no.shift.confirmed, 2, function(x)mean(x, na.rm = T))
```





